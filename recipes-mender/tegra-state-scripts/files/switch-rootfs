#!/bin/sh

#
# Mender update flow:
#  1. Mender downloads .mender artifact
#  2. Mender extracts and writes rootfs to inactive partition (APP_a or APP_b)
#  3. ArtifactInstall_Leave state -> switch-rootfs executes:
#     (after rootfs is written, before reboot)
#     - Flips boot slot (nvbootctrl -t rootfs set-active-boot-slot)
#     - Mounts inactive partition to check for bootloader update marker
#     - If marker exists: stages UEFI capsule to ESP and sets OSIndications
#  4. System reboots
#  5. UEFI firmware processes capsule (if staged)
#  6. System boots from new rootfs
#  7. ArtifactVerifyReboot state -> verify-bootloader-update executes:
#     (after reboot, before commit)
#     - Verifies bootloader version changed (if capsule was staged)
#     - Checks ESRT status for capsule update result
#  8. Mender commits the update (makes it permanent)
#
# Mender state script: ArtifactInstall_Leave_50_switch-rootfs
# Jetson Orin (UEFI) + JetPack 6 (R36.x) + Mender
# - Flips rootfs slot using nvbootctrl
# - Optionally (and safely) stages a UEFI capsule only when requested
#

set -eu

# EdgeOS Custom Implementation
EDGEOS_SWITCH_ROOTFS_VERSION="0.1.0"

log() {
    printf '%s\n' "mender-switch-rootfs: $*" >&2
}

# Mender's script environment can be minimal, make sure the tools are reachable
export PATH=/usr/sbin:/sbin:/usr/bin:/bin:$PATH

require() {
    if ! command -v "$1" >/dev/null 2>&1; then
        log "ERROR: required tool '$1' not found in PATH=${PATH}"
        exit 1
    fi
}

require nvbootctrl
require blkid
require lsblk
require findmnt

# Map slot number -> suffix used by NVIDIA partition labels
slot_suffix() {
    case "$1" in
        0) echo "a" ;;
        1) echo "b" ;;
        *) log "ERROR: unexpected slot '$1'"; exit 1 ;;
    esac
}

# Resolve the block device path (/dev/…) for the inactive rootfs partition
resolve_inactive_part() {
    next_slot="$1"                       # 0 or 1
    suf="$(slot_suffix "$next_slot")"    # "a" or "b"

    # 1) Fast path: /dev/disk/by-partlabel/APP_a or APP_b (common on R36.x)
    if [ -e "/dev/disk/by-partlabel/APP_${suf}" ]
    then
        readlink -f "/dev/disk/by-partlabel/APP_${suf}"
        return 0
    fi

    # 2) Fall back to scanning lsblk PARTLABELs for APP_a / APP_b
    #    Works regardless of underlying disk (eMMC/NVMe/SD)
    dev="$(lsblk -rno PATH,PARTLABEL | awk -v want="APP_${suf}" '$2 == want {print $1; exit}')"
    if [ -n "${dev:-}" ] && [ -e "${dev}" ]
    then
        echo "${dev}"
        return 0
    fi

    # 3) Some layouts keep APP label but encode slot in PARTUUID vars; try nv_boot_control.conf
    if [ -r /etc/nv_boot_control.conf ]; then
        # Look for ROOTFS_PARTUUID_A / ROOTFS_PARTUUID_B style keys
        key="ROOTFS_PARTUUID_$(printf '%s' "$suf" | tr 'ab' 'AB')"
        uuid="$(awk -F= -v k="$key" '$1==k {print $2}' /etc/nv_boot_control.conf | tr -d ' \t\r')"
        if [ -n "${uuid:-}" ] && [ -e "/dev/disk/by-partuuid/${uuid}" ]; then
            readlink -f "/dev/disk/by-partuuid/${uuid}"
            return 0
        fi
    fi

    # 4) Last resort: infer by taking current rootfs device and toggling the partition number
    #    (only works on simple mmcblk0pX/nvme0n1pX schemes where a/b are consecutive).
    cur_src="$(findmnt -no SOURCE / || true)"
    if [ -n "${cur_src:-}" ]; then
        case "${cur_src}" in
            /dev/mmcblk*p*[0-9]*|/dev/nvme*n*p[0-9]*)
                num="${cur_src##*p}"; base="${cur_src%p*}"
                case "${num}" in
                    *[!0-9]*) ;; # not purely numeric; skip
                    *)
                        if [ "${next_slot}" = "0" ]; then
                            cand="${base}p$(( num - 1 ))"
                        else
                            cand="${base}p$(( num + 1 ))"
                        fi

                        if [ -e "${cand}" ]; then
                            echo "${cand}"
                            return 0
                        fi
                    ;;
                esac
            ;;
        esac
    fi

    log "ERROR: could not resolve inactive rootfs partition for slot ${next_slot}"
    exit 1
}

# Determine current and next rootfs slot
cur="$(nvbootctrl -t rootfs get-current-slot)"
case "${cur}" in
    0) next=1 ;;
    1) next=0 ;;
    *) log "ERROR: nvbootctrl returned unexpected current slot '${cur}'"; exit 1 ;;
esac

log "current slot: ${cur}"
log "next slot: ${next}"

# Resolve inactive partition
inactive_part="$(resolve_inactive_part "$next")"
log "inactive partition: ${inactive_part}"

###############################################################################
# Boot Chain Switching Strategy
#
# NVIDIA's boot chain architecture links bootloader firmware and rootfs slots:
#   Boot Chain 0 → Bootloader Chain 0 + Rootfs Slot 0 (partition 1)
#   Boot Chain 1 → Bootloader Chain 1 + Rootfs Slot 1 (partition 2)
#
# Two update scenarios:
#
# 1. CAPSULE UPDATE (Rootfs + Bootloader):
#    - UEFI capsule writes bootloader firmware to inactive boot chain
#    - Capsule calls UpdateFwChain() to switch BCT to new chain
#    - L4TLauncher reads new boot chain and boots corresponding rootfs slot
#    - ATOMIC: Bootloader and rootfs switch together
#    - NO nvbootctrl call needed (would cause BC_NEXT conflict)
#
# 2. ROOTFS-ONLY UPDATE:
#    - Only rootfs partition updated, bootloader unchanged
#    - Must call nvbootctrl to switch boot chain manually
#    - HandleBootChainUpdate() processes BC_NEXT and updates BCT
#    - System reboots to new boot chain with new rootfs
###############################################################################

# Check if bootloader update capsule will be staged
marker_rel="/var/lib/edgeos/update-bootloader"
mount_dir="/mnt/inactive"
will_stage_capsule=0

mkdir -p "$mount_dir"
if mount "${inactive_part}" "${mount_dir}" 2>/dev/null
then
    if [ -f "${mount_dir}${marker_rel}" ]
    then
        will_stage_capsule=1
        log "bootloader update marker found: will stage capsule"
    fi
    umount "${mount_dir}" || true
else
    log "WARN: could not mount inactive rootfs (${inactive_part})"
fi

# Switch boot chain based on update type
if [ "${will_stage_capsule}" -eq 1 ]
then
    log "CAPSULE UPDATE: boot chain switch will be handled by UEFI firmware"
    log "NOT calling nvbootctrl (would cause BC_NEXT conflict)"
else
    log "ROOTFS-ONLY UPDATE: manually switching boot chain"
    nvbootctrl -t rootfs set-active-boot-slot "${next}"
    log "set active boot slot: ${next} OK"
fi

###############################################################################
# UEFI Capsule Staging (Atomic Bootloader + Rootfs Updates)
#
# If a marker file exists in the newly updated rootfs, stage the UEFI capsule
# to the ESP for processing on next boot. This ensures bootloader and rootfs
# versions stay synchronized during major L4T version upgrades.
#
# Marker file: /var/lib/edgeos/update-bootloader
# Capsule location: /opt/nvidia/UpdateCapsule/tegra-bl.cap
# ESP staging: /boot/efi/EFI/UpdateCapsule/TEGRA_BL.Cap
###############################################################################

maybe_stage_capsule() {
    marker_rel="/var/lib/edgeos/update-bootloader"
    mount_dir="/mnt/inactive"
    esp_dir=""
    need_capsule=0

    mkdir -p "$mount_dir"
    if ! mount "${inactive_part}" "${mount_dir}"
    then
        log "WARN: could not mount inactive rootfs (${inactive_part})"
        log "skipping capsule staging"
        return 0
    fi

    if [ -f "${mount_dir}${marker_rel}" ]
    then
        need_capsule=1
        log "bootloader update marker found: ${marker_rel}"

        # Save current bootloader version for post-reboot verification
        if command -v nvbootctrl >/dev/null 2>&1; then
            current_bl_version=$(nvbootctrl dump-slots-info 2>/dev/null | grep -i "Current version" | awk '{print $3}')
            if [ -n "$current_bl_version" ]; then
                log "current bootloader version: ${current_bl_version}"
                mkdir -p /var/lib/mender
                echo "$current_bl_version" > /var/lib/mender/tegra-bl-version-before
                log "saved version for post-reboot verification"
            else
                log "WARN: could not determine current bootloader version"
            fi
        fi
    fi

    if [ "${need_capsule}" -eq 1 ]
    then
        require oe4t-set-uefi-OSIndications

        # Detect ESP mount point (/boot/efi is standard; otherwise try to mount it)
        if findmnt -no TARGET /boot/efi >/dev/null 2>&1; then
            esp_dir="/boot/efi"
        else
            # Try common ESP by-partlabel
            if [ -e /dev/disk/by-partlabel/UEFI-ESP ]
            then
                mkdir -p /boot/efi
                mount /dev/disk/by-partlabel/UEFI-ESP /boot/efi || {
                    umount "${mount_dir}" || true
                    log "ERROR: failed to mount ESP; cannot stage capsule"
                    exit 1
                }
                esp_dir="/boot/efi"
            else
                umount "${mount_dir}" || true
                log "ERROR: ESP not mounted and /dev/disk/by-partlabel/UEFI-ESP missing"
                exit 1
            fi
        fi

        cap_src="${mount_dir}/opt/nvidia/UpdateCapsule/tegra-bl.cap"
        cap_dst="${esp_dir}/EFI/UpdateCapsule/TEGRA_BL.Cap"

        if [ ! -f "${cap_src}" ]
        then
            umount "${mount_dir}" || true
            log "ERROR: BL update requested but capsule not found (${cap_src})"
            exit 1
        fi

        mkdir -p "$(dirname "$cap_dst")"
        cp -f "${cap_src}" "${cap_dst}"
        sync

        if command -v oe4t-set-uefi-OSIndications >/dev/null 2>&1
        then
            oe4t-set-uefi-OSIndications || {
                log "ERROR: Failed to set OSIndications variable"
                umount "${mount_dir}" || true
                exit 1
            }

            # Verify OSIndications was written correctly (bit 2 set for capsule processing)
            # Per UEFI spec, SetVariable() is synchronous - write completes before return
            osind_file="/sys/firmware/efi/efivars/OsIndications-8be4df61-93ca-11d2-aa0d-00e098032b8c"
            if [ -r "$osind_file" ]; then
                # Read byte at offset 4 (skip 4-byte attribute header)
                value=$(dd if="$osind_file" bs=1 skip=4 count=1 2>/dev/null | od -An -tu1 | tr -d ' ')
                # Check if bit 2 is set (value & 0x04 == 0x04)
                if [ "$((value & 4))" -eq 4 ]; then
                    log "staged capsule to ESP OK; OSIndications verified (0x$(printf '%02x' $value))"
                else
                    log "ERROR: OSIndications not set correctly (got 0x$(printf '%02x' $value), expected bit 2 set)"
                    umount "${mount_dir}" || true
                    exit 1
                fi
            else
                log "WARN: Cannot verify OSIndications, file not readable"
                log "staged capsule to ESP OK; OSIndications set (not verified)"
            fi
        else
            log "ERROR: oe4t-set-uefi-OSIndications not found, capsule may not be processed"
            umount "${mount_dir}" || true
            exit 1
        fi
    else
        log "no bootloader update marker, skipping capsule staging"
    fi

    umount "${mount_dir}" || true
}

# Stage capsule if marker file is present in new rootfs
maybe_stage_capsule

exit 0
