#!/bin/sh

#
# Mender state script: ArtifactInstall_Leave_50_switch-rootfs
# Jetson Orin (UEFI) + JetPack 6 (R36.x) + Mender
# - Flips rootfs slot using nvbootctrl
# - Optionally (and safely) stages a UEFI capsule only when requested
#

set -eu

log() {
    printf '%s\n' "mender-switch-rootfs: $*" >&2
}

# Mender's script environment can be minimal, make sure the tools are reachable
export PATH=/usr/sbin:/sbin:/usr/bin:/bin:$PATH

require() {
    if ! command -v "$1" >/dev/null 2>&1; then
        log "ERROR: required tool '$1' not found in PATH=${PATH}"
        exit 1
    fi
}

require nvbootctrl
require blkid
require lsblk
require findmnt

# Map slot number -> suffix used by NVIDIA partition labels
slot_suffix() {
    case "$1" in
        0) echo "a" ;;
        1) echo "b" ;;
        *) log "ERROR: unexpected slot '$1'"; exit 1 ;;
    esac
}

# Resolve the block device path (/dev/…) for the inactive rootfs partition
resolve_inactive_part() {
    next_slot="$1"                       # 0 or 1
    suf="$(slot_suffix "$next_slot")"    # "a" or "b"

    # 1) Fast path: /dev/disk/by-partlabel/APP_a or APP_b (common on R36.x)
    if [ -e "/dev/disk/by-partlabel/APP_${suf}" ]
    then
        readlink -f "/dev/disk/by-partlabel/APP_${suf}"
        return 0
    fi

    # 2) Fall back to scanning lsblk PARTLABELs for APP_a / APP_b
    #    Works regardless of underlying disk (eMMC/NVMe/SD)
    dev="$(lsblk -rno PATH,PARTLABEL | awk -v want="APP_${suf}" '$2 == want {print $1; exit}')"
    if [ -n "${dev:-}" ] && [ -e "${dev}" ]
    then
        echo "${dev}"
        return 0
    fi

    # 3) Some layouts keep APP label but encode slot in PARTUUID vars; try nv_boot_control.conf
    if [ -r /etc/nv_boot_control.conf ]; then
        # Look for ROOTFS_PARTUUID_A / ROOTFS_PARTUUID_B style keys
        key="ROOTFS_PARTUUID_$(printf '%s' "$suf" | tr 'ab' 'AB')"
        uuid="$(awk -F= -v k="$key" '$1==k {print $2}' /etc/nv_boot_control.conf | tr -d ' \t\r')"
        if [ -n "${uuid:-}" ] && [ -e "/dev/disk/by-partuuid/${uuid}" ]; then
            readlink -f "/dev/disk/by-partuuid/${uuid}"
            return 0
        fi
    fi

    # 4) Last resort: infer by taking current rootfs device and toggling the partition number
    #    (only works on simple mmcblk0pX/nvme0n1pX schemes where a/b are consecutive).
    cur_src="$(findmnt -no SOURCE / || true)"
    if [ -n "${cur_src:-}" ]; then
        case "${cur_src}" in
            /dev/mmcblk*p*[0-9]*|/dev/nvme*n*p[0-9]*)
                num="${cur_src##*p}"; base="${cur_src%p*}"
                case "${num}" in
                    *[!0-9]*) ;; # not purely numeric; skip
                    *)
                        if [ "${next_slot}" = "0" ]; then
                            cand="${base}p$(( num - 1 ))"
                        else
                            cand="${base}p$(( num + 1 ))"
                        fi

                        if [ -e "${cand}" ]; then
                            echo "${cand}"
                            return 0
                        fi
                    ;;
                esac
            ;;
        esac
    fi

    log "ERROR: could not resolve inactive rootfs partition for slot ${next_slot}"
    exit 1
}

# Flip to the inactive rootfs slot
cur="$(nvbootctrl -t rootfs get-current-slot)"
case "${cur}" in
    0) next=1 ;;
    1) next=0 ;;
    *) log "ERROR: nvbootctrl returned unexpected current slot '${cur}'"; exit 1 ;;
esac

log "current slot: ${cur}"
log "next slot: ${next}"

# Optionally resolve inactive part (needed only if we might stage a capsule)
inactive_part="$(resolve_inactive_part "$next")"
log "inactive partition: ${inactive_part}"

# Do the slot switch now; this is the *only* mandatory action
nvbootctrl -t rootfs set-active-boot-slot "${next}"
log "set active boot slot: ${next} OK"

###############################################################################
# Stage a bootloader capsule *ONLY IF* the newly installed rootfs
# explicitly requests it via marker file:
#    /var/lib/edgeos/update-bootloader  (inside the inactive rootfs)
#
# On Orin UEFI, capsule processing can rewrite boot-control
# state during the next boot and undo the slot flip.
# Only do this when you’re actually updating BL, and you accept that behavior.
###############################################################################
maybe_stage_capsule() {
    marker_rel="/var/lib/edgeos/update-bootloader"
    mount_dir="/mnt/inactive"
    esp_dir=""
    need_capsule=0

    mkdir -p "$mount_dir"
    if ! mount "${inactive_part}" "${mount_dir}"
    then
        log "WARN: could not mount inactive rootfs (${mount_dir})"
        log "skipping capsule check"
        return 0
    fi

    if [ -f "${mount_dir}${marker_rel}" ]
    then
        need_capsule=1
    fi

    if [ "${need_capsule}" -eq 1 ]
    then
        require oe4t-set-uefi-OSIndications

        # Detect ESP mount point (/boot/efi is standard; otherwise try to mount it)
        if findmnt -no TARGET /boot/efi >/dev/null 2>&1; then
            esp_dir="/boot/efi"
        else
            # Try common ESP by-partlabel
            if [ -e /dev/disk/by-partlabel/UEFI-ESP ]
            then
                mkdir -p /boot/efi
                mount /dev/disk/by-partlabel/UEFI-ESP /boot/efi || {
                    umount "${mount_dir}" || true
                    log "ERROR: failed to mount ESP; cannot stage capsule"
                    exit 1
                }

                esp_dir="/boot/efi"
            else
                umount "${mount_dir}" || true
                log "ERROR: ESP not mounted and /dev/disk/by-partlabel/UEFI-ESP missing"
                exit 1
            fi
        fi

        cap_src="${mount_dir}/opt/nvidia/UpdateCapsule/tegra-bl.cap"
        cap_dst="${esp_dir}/EFI/UpdateCapsule/TEGRA_BL.Cap"

        if [ ! -f "${cap_src}" ]
        then
            umount "${mount_dir}" || true
            log "ERROR: BL update requested but capsule not found (${cap_src})"
            exit 1
        fi

        mkdir -p "$(dirname "$cap_dst")"
        cp -f "${cap_src}" "${cap_dst}"
        sync

        if command -v oe4t-set-uefi-OSIndications >/dev/null 2>&1
        then
            oe4t-set-uefi-OSIndications
            log "staged capsule to ESP OK; OSIndications set"
        else
            log "ERROR: oe4t-set-uefi-OSIndications not found, capsule may not be processed"
            umount "${mount_dir}" || true
            exit 1
        fi
    else
        log "no bootloader update requested, skipping capsule"
    fi

    umount "${mount_dir}" || true
}

# Comment out the next line if you never update the bootloader via capsule
maybe_stage_capsule

exit 0
